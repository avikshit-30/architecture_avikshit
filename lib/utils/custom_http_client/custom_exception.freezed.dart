// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'custom_exception.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$CustomException {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() authNeededForAccessError,
    required TResult Function(String status) backStableError,
    required TResult Function() backUnstableError,
    required TResult Function() unknownServerError,
    required TResult Function(String status) modelParsingError,
    required TResult Function() qunatityCantBeZero,
    required TResult Function(String status) customError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? authNeededForAccessError,
    TResult? Function(String status)? backStableError,
    TResult? Function()? backUnstableError,
    TResult? Function()? unknownServerError,
    TResult? Function(String status)? modelParsingError,
    TResult? Function()? qunatityCantBeZero,
    TResult? Function(String status)? customError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? authNeededForAccessError,
    TResult Function(String status)? backStableError,
    TResult Function()? backUnstableError,
    TResult Function()? unknownServerError,
    TResult Function(String status)? modelParsingError,
    TResult Function()? qunatityCantBeZero,
    TResult Function(String status)? customError,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(authNeededForAccessError value)
        authNeededForAccessError,
    required TResult Function(BackStableError value) backStableError,
    required TResult Function(BackUnstableError value) backUnstableError,
    required TResult Function(UnknownServerError value) unknownServerError,
    required TResult Function(ModelParsingError value) modelParsingError,
    required TResult Function(QunatityCantBeZero value) qunatityCantBeZero,
    required TResult Function(CustomError value) customError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(authNeededForAccessError value)? authNeededForAccessError,
    TResult? Function(BackStableError value)? backStableError,
    TResult? Function(BackUnstableError value)? backUnstableError,
    TResult? Function(UnknownServerError value)? unknownServerError,
    TResult? Function(ModelParsingError value)? modelParsingError,
    TResult? Function(QunatityCantBeZero value)? qunatityCantBeZero,
    TResult? Function(CustomError value)? customError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(authNeededForAccessError value)? authNeededForAccessError,
    TResult Function(BackStableError value)? backStableError,
    TResult Function(BackUnstableError value)? backUnstableError,
    TResult Function(UnknownServerError value)? unknownServerError,
    TResult Function(ModelParsingError value)? modelParsingError,
    TResult Function(QunatityCantBeZero value)? qunatityCantBeZero,
    TResult Function(CustomError value)? customError,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CustomExceptionCopyWith<$Res> {
  factory $CustomExceptionCopyWith(
          CustomException value, $Res Function(CustomException) then) =
      _$CustomExceptionCopyWithImpl<$Res, CustomException>;
}

/// @nodoc
class _$CustomExceptionCopyWithImpl<$Res, $Val extends CustomException>
    implements $CustomExceptionCopyWith<$Res> {
  _$CustomExceptionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$authNeededForAccessErrorCopyWith<$Res> {
  factory _$$authNeededForAccessErrorCopyWith(_$authNeededForAccessError value,
          $Res Function(_$authNeededForAccessError) then) =
      __$$authNeededForAccessErrorCopyWithImpl<$Res>;
}

/// @nodoc
class __$$authNeededForAccessErrorCopyWithImpl<$Res>
    extends _$CustomExceptionCopyWithImpl<$Res, _$authNeededForAccessError>
    implements _$$authNeededForAccessErrorCopyWith<$Res> {
  __$$authNeededForAccessErrorCopyWithImpl(_$authNeededForAccessError _value,
      $Res Function(_$authNeededForAccessError) _then)
      : super(_value, _then);
}

/// @nodoc

class _$authNeededForAccessError implements authNeededForAccessError {
  const _$authNeededForAccessError();

  @override
  String toString() {
    return 'CustomException.authNeededForAccessError()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$authNeededForAccessError);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() authNeededForAccessError,
    required TResult Function(String status) backStableError,
    required TResult Function() backUnstableError,
    required TResult Function() unknownServerError,
    required TResult Function(String status) modelParsingError,
    required TResult Function() qunatityCantBeZero,
    required TResult Function(String status) customError,
  }) {
    return authNeededForAccessError();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? authNeededForAccessError,
    TResult? Function(String status)? backStableError,
    TResult? Function()? backUnstableError,
    TResult? Function()? unknownServerError,
    TResult? Function(String status)? modelParsingError,
    TResult? Function()? qunatityCantBeZero,
    TResult? Function(String status)? customError,
  }) {
    return authNeededForAccessError?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? authNeededForAccessError,
    TResult Function(String status)? backStableError,
    TResult Function()? backUnstableError,
    TResult Function()? unknownServerError,
    TResult Function(String status)? modelParsingError,
    TResult Function()? qunatityCantBeZero,
    TResult Function(String status)? customError,
    required TResult orElse(),
  }) {
    if (authNeededForAccessError != null) {
      return authNeededForAccessError();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(authNeededForAccessError value)
        authNeededForAccessError,
    required TResult Function(BackStableError value) backStableError,
    required TResult Function(BackUnstableError value) backUnstableError,
    required TResult Function(UnknownServerError value) unknownServerError,
    required TResult Function(ModelParsingError value) modelParsingError,
    required TResult Function(QunatityCantBeZero value) qunatityCantBeZero,
    required TResult Function(CustomError value) customError,
  }) {
    return authNeededForAccessError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(authNeededForAccessError value)? authNeededForAccessError,
    TResult? Function(BackStableError value)? backStableError,
    TResult? Function(BackUnstableError value)? backUnstableError,
    TResult? Function(UnknownServerError value)? unknownServerError,
    TResult? Function(ModelParsingError value)? modelParsingError,
    TResult? Function(QunatityCantBeZero value)? qunatityCantBeZero,
    TResult? Function(CustomError value)? customError,
  }) {
    return authNeededForAccessError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(authNeededForAccessError value)? authNeededForAccessError,
    TResult Function(BackStableError value)? backStableError,
    TResult Function(BackUnstableError value)? backUnstableError,
    TResult Function(UnknownServerError value)? unknownServerError,
    TResult Function(ModelParsingError value)? modelParsingError,
    TResult Function(QunatityCantBeZero value)? qunatityCantBeZero,
    TResult Function(CustomError value)? customError,
    required TResult orElse(),
  }) {
    if (authNeededForAccessError != null) {
      return authNeededForAccessError(this);
    }
    return orElse();
  }
}

abstract class authNeededForAccessError implements CustomException {
  const factory authNeededForAccessError() = _$authNeededForAccessError;
}

/// @nodoc
abstract class _$$BackStableErrorCopyWith<$Res> {
  factory _$$BackStableErrorCopyWith(
          _$BackStableError value, $Res Function(_$BackStableError) then) =
      __$$BackStableErrorCopyWithImpl<$Res>;
  @useResult
  $Res call({String status});
}

/// @nodoc
class __$$BackStableErrorCopyWithImpl<$Res>
    extends _$CustomExceptionCopyWithImpl<$Res, _$BackStableError>
    implements _$$BackStableErrorCopyWith<$Res> {
  __$$BackStableErrorCopyWithImpl(
      _$BackStableError _value, $Res Function(_$BackStableError) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? status = null,
  }) {
    return _then(_$BackStableError(
      null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$BackStableError implements BackStableError {
  const _$BackStableError(this.status);

  @override
  final String status;

  @override
  String toString() {
    return 'CustomException.backStableError(status: $status)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BackStableError &&
            (identical(other.status, status) || other.status == status));
  }

  @override
  int get hashCode => Object.hash(runtimeType, status);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$BackStableErrorCopyWith<_$BackStableError> get copyWith =>
      __$$BackStableErrorCopyWithImpl<_$BackStableError>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() authNeededForAccessError,
    required TResult Function(String status) backStableError,
    required TResult Function() backUnstableError,
    required TResult Function() unknownServerError,
    required TResult Function(String status) modelParsingError,
    required TResult Function() qunatityCantBeZero,
    required TResult Function(String status) customError,
  }) {
    return backStableError(status);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? authNeededForAccessError,
    TResult? Function(String status)? backStableError,
    TResult? Function()? backUnstableError,
    TResult? Function()? unknownServerError,
    TResult? Function(String status)? modelParsingError,
    TResult? Function()? qunatityCantBeZero,
    TResult? Function(String status)? customError,
  }) {
    return backStableError?.call(status);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? authNeededForAccessError,
    TResult Function(String status)? backStableError,
    TResult Function()? backUnstableError,
    TResult Function()? unknownServerError,
    TResult Function(String status)? modelParsingError,
    TResult Function()? qunatityCantBeZero,
    TResult Function(String status)? customError,
    required TResult orElse(),
  }) {
    if (backStableError != null) {
      return backStableError(status);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(authNeededForAccessError value)
        authNeededForAccessError,
    required TResult Function(BackStableError value) backStableError,
    required TResult Function(BackUnstableError value) backUnstableError,
    required TResult Function(UnknownServerError value) unknownServerError,
    required TResult Function(ModelParsingError value) modelParsingError,
    required TResult Function(QunatityCantBeZero value) qunatityCantBeZero,
    required TResult Function(CustomError value) customError,
  }) {
    return backStableError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(authNeededForAccessError value)? authNeededForAccessError,
    TResult? Function(BackStableError value)? backStableError,
    TResult? Function(BackUnstableError value)? backUnstableError,
    TResult? Function(UnknownServerError value)? unknownServerError,
    TResult? Function(ModelParsingError value)? modelParsingError,
    TResult? Function(QunatityCantBeZero value)? qunatityCantBeZero,
    TResult? Function(CustomError value)? customError,
  }) {
    return backStableError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(authNeededForAccessError value)? authNeededForAccessError,
    TResult Function(BackStableError value)? backStableError,
    TResult Function(BackUnstableError value)? backUnstableError,
    TResult Function(UnknownServerError value)? unknownServerError,
    TResult Function(ModelParsingError value)? modelParsingError,
    TResult Function(QunatityCantBeZero value)? qunatityCantBeZero,
    TResult Function(CustomError value)? customError,
    required TResult orElse(),
  }) {
    if (backStableError != null) {
      return backStableError(this);
    }
    return orElse();
  }
}

abstract class BackStableError implements CustomException {
  const factory BackStableError(final String status) = _$BackStableError;

  String get status;
  @JsonKey(ignore: true)
  _$$BackStableErrorCopyWith<_$BackStableError> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$BackUnstableErrorCopyWith<$Res> {
  factory _$$BackUnstableErrorCopyWith(
          _$BackUnstableError value, $Res Function(_$BackUnstableError) then) =
      __$$BackUnstableErrorCopyWithImpl<$Res>;
}

/// @nodoc
class __$$BackUnstableErrorCopyWithImpl<$Res>
    extends _$CustomExceptionCopyWithImpl<$Res, _$BackUnstableError>
    implements _$$BackUnstableErrorCopyWith<$Res> {
  __$$BackUnstableErrorCopyWithImpl(
      _$BackUnstableError _value, $Res Function(_$BackUnstableError) _then)
      : super(_value, _then);
}

/// @nodoc

class _$BackUnstableError implements BackUnstableError {
  const _$BackUnstableError();

  @override
  String toString() {
    return 'CustomException.backUnstableError()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$BackUnstableError);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() authNeededForAccessError,
    required TResult Function(String status) backStableError,
    required TResult Function() backUnstableError,
    required TResult Function() unknownServerError,
    required TResult Function(String status) modelParsingError,
    required TResult Function() qunatityCantBeZero,
    required TResult Function(String status) customError,
  }) {
    return backUnstableError();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? authNeededForAccessError,
    TResult? Function(String status)? backStableError,
    TResult? Function()? backUnstableError,
    TResult? Function()? unknownServerError,
    TResult? Function(String status)? modelParsingError,
    TResult? Function()? qunatityCantBeZero,
    TResult? Function(String status)? customError,
  }) {
    return backUnstableError?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? authNeededForAccessError,
    TResult Function(String status)? backStableError,
    TResult Function()? backUnstableError,
    TResult Function()? unknownServerError,
    TResult Function(String status)? modelParsingError,
    TResult Function()? qunatityCantBeZero,
    TResult Function(String status)? customError,
    required TResult orElse(),
  }) {
    if (backUnstableError != null) {
      return backUnstableError();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(authNeededForAccessError value)
        authNeededForAccessError,
    required TResult Function(BackStableError value) backStableError,
    required TResult Function(BackUnstableError value) backUnstableError,
    required TResult Function(UnknownServerError value) unknownServerError,
    required TResult Function(ModelParsingError value) modelParsingError,
    required TResult Function(QunatityCantBeZero value) qunatityCantBeZero,
    required TResult Function(CustomError value) customError,
  }) {
    return backUnstableError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(authNeededForAccessError value)? authNeededForAccessError,
    TResult? Function(BackStableError value)? backStableError,
    TResult? Function(BackUnstableError value)? backUnstableError,
    TResult? Function(UnknownServerError value)? unknownServerError,
    TResult? Function(ModelParsingError value)? modelParsingError,
    TResult? Function(QunatityCantBeZero value)? qunatityCantBeZero,
    TResult? Function(CustomError value)? customError,
  }) {
    return backUnstableError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(authNeededForAccessError value)? authNeededForAccessError,
    TResult Function(BackStableError value)? backStableError,
    TResult Function(BackUnstableError value)? backUnstableError,
    TResult Function(UnknownServerError value)? unknownServerError,
    TResult Function(ModelParsingError value)? modelParsingError,
    TResult Function(QunatityCantBeZero value)? qunatityCantBeZero,
    TResult Function(CustomError value)? customError,
    required TResult orElse(),
  }) {
    if (backUnstableError != null) {
      return backUnstableError(this);
    }
    return orElse();
  }
}

abstract class BackUnstableError implements CustomException {
  const factory BackUnstableError() = _$BackUnstableError;
}

/// @nodoc
abstract class _$$UnknownServerErrorCopyWith<$Res> {
  factory _$$UnknownServerErrorCopyWith(_$UnknownServerError value,
          $Res Function(_$UnknownServerError) then) =
      __$$UnknownServerErrorCopyWithImpl<$Res>;
}

/// @nodoc
class __$$UnknownServerErrorCopyWithImpl<$Res>
    extends _$CustomExceptionCopyWithImpl<$Res, _$UnknownServerError>
    implements _$$UnknownServerErrorCopyWith<$Res> {
  __$$UnknownServerErrorCopyWithImpl(
      _$UnknownServerError _value, $Res Function(_$UnknownServerError) _then)
      : super(_value, _then);
}

/// @nodoc

class _$UnknownServerError implements UnknownServerError {
  const _$UnknownServerError();

  @override
  String toString() {
    return 'CustomException.unknownServerError()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$UnknownServerError);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() authNeededForAccessError,
    required TResult Function(String status) backStableError,
    required TResult Function() backUnstableError,
    required TResult Function() unknownServerError,
    required TResult Function(String status) modelParsingError,
    required TResult Function() qunatityCantBeZero,
    required TResult Function(String status) customError,
  }) {
    return unknownServerError();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? authNeededForAccessError,
    TResult? Function(String status)? backStableError,
    TResult? Function()? backUnstableError,
    TResult? Function()? unknownServerError,
    TResult? Function(String status)? modelParsingError,
    TResult? Function()? qunatityCantBeZero,
    TResult? Function(String status)? customError,
  }) {
    return unknownServerError?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? authNeededForAccessError,
    TResult Function(String status)? backStableError,
    TResult Function()? backUnstableError,
    TResult Function()? unknownServerError,
    TResult Function(String status)? modelParsingError,
    TResult Function()? qunatityCantBeZero,
    TResult Function(String status)? customError,
    required TResult orElse(),
  }) {
    if (unknownServerError != null) {
      return unknownServerError();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(authNeededForAccessError value)
        authNeededForAccessError,
    required TResult Function(BackStableError value) backStableError,
    required TResult Function(BackUnstableError value) backUnstableError,
    required TResult Function(UnknownServerError value) unknownServerError,
    required TResult Function(ModelParsingError value) modelParsingError,
    required TResult Function(QunatityCantBeZero value) qunatityCantBeZero,
    required TResult Function(CustomError value) customError,
  }) {
    return unknownServerError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(authNeededForAccessError value)? authNeededForAccessError,
    TResult? Function(BackStableError value)? backStableError,
    TResult? Function(BackUnstableError value)? backUnstableError,
    TResult? Function(UnknownServerError value)? unknownServerError,
    TResult? Function(ModelParsingError value)? modelParsingError,
    TResult? Function(QunatityCantBeZero value)? qunatityCantBeZero,
    TResult? Function(CustomError value)? customError,
  }) {
    return unknownServerError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(authNeededForAccessError value)? authNeededForAccessError,
    TResult Function(BackStableError value)? backStableError,
    TResult Function(BackUnstableError value)? backUnstableError,
    TResult Function(UnknownServerError value)? unknownServerError,
    TResult Function(ModelParsingError value)? modelParsingError,
    TResult Function(QunatityCantBeZero value)? qunatityCantBeZero,
    TResult Function(CustomError value)? customError,
    required TResult orElse(),
  }) {
    if (unknownServerError != null) {
      return unknownServerError(this);
    }
    return orElse();
  }
}

abstract class UnknownServerError implements CustomException {
  const factory UnknownServerError() = _$UnknownServerError;
}

/// @nodoc
abstract class _$$ModelParsingErrorCopyWith<$Res> {
  factory _$$ModelParsingErrorCopyWith(
          _$ModelParsingError value, $Res Function(_$ModelParsingError) then) =
      __$$ModelParsingErrorCopyWithImpl<$Res>;
  @useResult
  $Res call({String status});
}

/// @nodoc
class __$$ModelParsingErrorCopyWithImpl<$Res>
    extends _$CustomExceptionCopyWithImpl<$Res, _$ModelParsingError>
    implements _$$ModelParsingErrorCopyWith<$Res> {
  __$$ModelParsingErrorCopyWithImpl(
      _$ModelParsingError _value, $Res Function(_$ModelParsingError) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? status = null,
  }) {
    return _then(_$ModelParsingError(
      null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$ModelParsingError implements ModelParsingError {
  const _$ModelParsingError(this.status);

  @override
  final String status;

  @override
  String toString() {
    return 'CustomException.modelParsingError(status: $status)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ModelParsingError &&
            (identical(other.status, status) || other.status == status));
  }

  @override
  int get hashCode => Object.hash(runtimeType, status);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ModelParsingErrorCopyWith<_$ModelParsingError> get copyWith =>
      __$$ModelParsingErrorCopyWithImpl<_$ModelParsingError>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() authNeededForAccessError,
    required TResult Function(String status) backStableError,
    required TResult Function() backUnstableError,
    required TResult Function() unknownServerError,
    required TResult Function(String status) modelParsingError,
    required TResult Function() qunatityCantBeZero,
    required TResult Function(String status) customError,
  }) {
    return modelParsingError(status);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? authNeededForAccessError,
    TResult? Function(String status)? backStableError,
    TResult? Function()? backUnstableError,
    TResult? Function()? unknownServerError,
    TResult? Function(String status)? modelParsingError,
    TResult? Function()? qunatityCantBeZero,
    TResult? Function(String status)? customError,
  }) {
    return modelParsingError?.call(status);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? authNeededForAccessError,
    TResult Function(String status)? backStableError,
    TResult Function()? backUnstableError,
    TResult Function()? unknownServerError,
    TResult Function(String status)? modelParsingError,
    TResult Function()? qunatityCantBeZero,
    TResult Function(String status)? customError,
    required TResult orElse(),
  }) {
    if (modelParsingError != null) {
      return modelParsingError(status);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(authNeededForAccessError value)
        authNeededForAccessError,
    required TResult Function(BackStableError value) backStableError,
    required TResult Function(BackUnstableError value) backUnstableError,
    required TResult Function(UnknownServerError value) unknownServerError,
    required TResult Function(ModelParsingError value) modelParsingError,
    required TResult Function(QunatityCantBeZero value) qunatityCantBeZero,
    required TResult Function(CustomError value) customError,
  }) {
    return modelParsingError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(authNeededForAccessError value)? authNeededForAccessError,
    TResult? Function(BackStableError value)? backStableError,
    TResult? Function(BackUnstableError value)? backUnstableError,
    TResult? Function(UnknownServerError value)? unknownServerError,
    TResult? Function(ModelParsingError value)? modelParsingError,
    TResult? Function(QunatityCantBeZero value)? qunatityCantBeZero,
    TResult? Function(CustomError value)? customError,
  }) {
    return modelParsingError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(authNeededForAccessError value)? authNeededForAccessError,
    TResult Function(BackStableError value)? backStableError,
    TResult Function(BackUnstableError value)? backUnstableError,
    TResult Function(UnknownServerError value)? unknownServerError,
    TResult Function(ModelParsingError value)? modelParsingError,
    TResult Function(QunatityCantBeZero value)? qunatityCantBeZero,
    TResult Function(CustomError value)? customError,
    required TResult orElse(),
  }) {
    if (modelParsingError != null) {
      return modelParsingError(this);
    }
    return orElse();
  }
}

abstract class ModelParsingError implements CustomException {
  const factory ModelParsingError(final String status) = _$ModelParsingError;

  String get status;
  @JsonKey(ignore: true)
  _$$ModelParsingErrorCopyWith<_$ModelParsingError> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$QunatityCantBeZeroCopyWith<$Res> {
  factory _$$QunatityCantBeZeroCopyWith(_$QunatityCantBeZero value,
          $Res Function(_$QunatityCantBeZero) then) =
      __$$QunatityCantBeZeroCopyWithImpl<$Res>;
}

/// @nodoc
class __$$QunatityCantBeZeroCopyWithImpl<$Res>
    extends _$CustomExceptionCopyWithImpl<$Res, _$QunatityCantBeZero>
    implements _$$QunatityCantBeZeroCopyWith<$Res> {
  __$$QunatityCantBeZeroCopyWithImpl(
      _$QunatityCantBeZero _value, $Res Function(_$QunatityCantBeZero) _then)
      : super(_value, _then);
}

/// @nodoc

class _$QunatityCantBeZero implements QunatityCantBeZero {
  const _$QunatityCantBeZero();

  @override
  String toString() {
    return 'CustomException.qunatityCantBeZero()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$QunatityCantBeZero);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() authNeededForAccessError,
    required TResult Function(String status) backStableError,
    required TResult Function() backUnstableError,
    required TResult Function() unknownServerError,
    required TResult Function(String status) modelParsingError,
    required TResult Function() qunatityCantBeZero,
    required TResult Function(String status) customError,
  }) {
    return qunatityCantBeZero();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? authNeededForAccessError,
    TResult? Function(String status)? backStableError,
    TResult? Function()? backUnstableError,
    TResult? Function()? unknownServerError,
    TResult? Function(String status)? modelParsingError,
    TResult? Function()? qunatityCantBeZero,
    TResult? Function(String status)? customError,
  }) {
    return qunatityCantBeZero?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? authNeededForAccessError,
    TResult Function(String status)? backStableError,
    TResult Function()? backUnstableError,
    TResult Function()? unknownServerError,
    TResult Function(String status)? modelParsingError,
    TResult Function()? qunatityCantBeZero,
    TResult Function(String status)? customError,
    required TResult orElse(),
  }) {
    if (qunatityCantBeZero != null) {
      return qunatityCantBeZero();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(authNeededForAccessError value)
        authNeededForAccessError,
    required TResult Function(BackStableError value) backStableError,
    required TResult Function(BackUnstableError value) backUnstableError,
    required TResult Function(UnknownServerError value) unknownServerError,
    required TResult Function(ModelParsingError value) modelParsingError,
    required TResult Function(QunatityCantBeZero value) qunatityCantBeZero,
    required TResult Function(CustomError value) customError,
  }) {
    return qunatityCantBeZero(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(authNeededForAccessError value)? authNeededForAccessError,
    TResult? Function(BackStableError value)? backStableError,
    TResult? Function(BackUnstableError value)? backUnstableError,
    TResult? Function(UnknownServerError value)? unknownServerError,
    TResult? Function(ModelParsingError value)? modelParsingError,
    TResult? Function(QunatityCantBeZero value)? qunatityCantBeZero,
    TResult? Function(CustomError value)? customError,
  }) {
    return qunatityCantBeZero?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(authNeededForAccessError value)? authNeededForAccessError,
    TResult Function(BackStableError value)? backStableError,
    TResult Function(BackUnstableError value)? backUnstableError,
    TResult Function(UnknownServerError value)? unknownServerError,
    TResult Function(ModelParsingError value)? modelParsingError,
    TResult Function(QunatityCantBeZero value)? qunatityCantBeZero,
    TResult Function(CustomError value)? customError,
    required TResult orElse(),
  }) {
    if (qunatityCantBeZero != null) {
      return qunatityCantBeZero(this);
    }
    return orElse();
  }
}

abstract class QunatityCantBeZero implements CustomException {
  const factory QunatityCantBeZero() = _$QunatityCantBeZero;
}

/// @nodoc
abstract class _$$CustomErrorCopyWith<$Res> {
  factory _$$CustomErrorCopyWith(
          _$CustomError value, $Res Function(_$CustomError) then) =
      __$$CustomErrorCopyWithImpl<$Res>;
  @useResult
  $Res call({String status});
}

/// @nodoc
class __$$CustomErrorCopyWithImpl<$Res>
    extends _$CustomExceptionCopyWithImpl<$Res, _$CustomError>
    implements _$$CustomErrorCopyWith<$Res> {
  __$$CustomErrorCopyWithImpl(
      _$CustomError _value, $Res Function(_$CustomError) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? status = null,
  }) {
    return _then(_$CustomError(
      null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$CustomError implements CustomError {
  const _$CustomError(this.status);

  @override
  final String status;

  @override
  String toString() {
    return 'CustomException.customError(status: $status)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CustomError &&
            (identical(other.status, status) || other.status == status));
  }

  @override
  int get hashCode => Object.hash(runtimeType, status);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CustomErrorCopyWith<_$CustomError> get copyWith =>
      __$$CustomErrorCopyWithImpl<_$CustomError>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() authNeededForAccessError,
    required TResult Function(String status) backStableError,
    required TResult Function() backUnstableError,
    required TResult Function() unknownServerError,
    required TResult Function(String status) modelParsingError,
    required TResult Function() qunatityCantBeZero,
    required TResult Function(String status) customError,
  }) {
    return customError(status);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? authNeededForAccessError,
    TResult? Function(String status)? backStableError,
    TResult? Function()? backUnstableError,
    TResult? Function()? unknownServerError,
    TResult? Function(String status)? modelParsingError,
    TResult? Function()? qunatityCantBeZero,
    TResult? Function(String status)? customError,
  }) {
    return customError?.call(status);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? authNeededForAccessError,
    TResult Function(String status)? backStableError,
    TResult Function()? backUnstableError,
    TResult Function()? unknownServerError,
    TResult Function(String status)? modelParsingError,
    TResult Function()? qunatityCantBeZero,
    TResult Function(String status)? customError,
    required TResult orElse(),
  }) {
    if (customError != null) {
      return customError(status);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(authNeededForAccessError value)
        authNeededForAccessError,
    required TResult Function(BackStableError value) backStableError,
    required TResult Function(BackUnstableError value) backUnstableError,
    required TResult Function(UnknownServerError value) unknownServerError,
    required TResult Function(ModelParsingError value) modelParsingError,
    required TResult Function(QunatityCantBeZero value) qunatityCantBeZero,
    required TResult Function(CustomError value) customError,
  }) {
    return customError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(authNeededForAccessError value)? authNeededForAccessError,
    TResult? Function(BackStableError value)? backStableError,
    TResult? Function(BackUnstableError value)? backUnstableError,
    TResult? Function(UnknownServerError value)? unknownServerError,
    TResult? Function(ModelParsingError value)? modelParsingError,
    TResult? Function(QunatityCantBeZero value)? qunatityCantBeZero,
    TResult? Function(CustomError value)? customError,
  }) {
    return customError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(authNeededForAccessError value)? authNeededForAccessError,
    TResult Function(BackStableError value)? backStableError,
    TResult Function(BackUnstableError value)? backUnstableError,
    TResult Function(UnknownServerError value)? unknownServerError,
    TResult Function(ModelParsingError value)? modelParsingError,
    TResult Function(QunatityCantBeZero value)? qunatityCantBeZero,
    TResult Function(CustomError value)? customError,
    required TResult orElse(),
  }) {
    if (customError != null) {
      return customError(this);
    }
    return orElse();
  }
}

abstract class CustomError implements CustomException {
  const factory CustomError(final String status) = _$CustomError;

  String get status;
  @JsonKey(ignore: true)
  _$$CustomErrorCopyWith<_$CustomError> get copyWith =>
      throw _privateConstructorUsedError;
}
